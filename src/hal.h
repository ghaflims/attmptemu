#ifndef _HAL_H_
#define _HAL_H_

#include <stdint.h>

#define FPS 60
#define SCREEN_W 256
#define SCREEN_H 240


// no point of this 2d array index represent x,y and the content represent the color..

// what makes a pixel position and color

typedef struct {
	int x,y;
	int c;
} pixel_t;

// this is helpful since we store non trasparent color only
typedef struct {
	pixel_t buf[264*264]; // include off screen pixel not for display tho
	int pos;
} pbuf_t;

// so we only put pixels if they are whithen screen
// so if the color is not transparent record it's position and color and increament the buffer
// why this instead of normal array buffer.. the answer is to support layering of buffer
// so the bg will be flushed and then the sprites..
// if normal array is used sprites will over ride bg layer
// so transparent sprites area will not be flushed hence the bg layer is not destoryed
#define putp(bf,xx,yy,cc) \
	do{ \
		if((xx)<SCREEN_W && (yy) <SCREEN_H){ \
			(bf).buf[(bf).pos].x = xx; \
			(bf).buf[(bf).pos].y = yy; \
			(bf).buf[(bf).pos].c = cc; \
			(bf).pos++; \
		} \
	} while(0)


// to clear the pixel buffer just reset the pos to zero..
#define pixelbuf_clear(bf) \
	do{ \
		(bf).pos=0; \
	} while(0)
	
typedef struct {
	uint8_t r;
	uint8_t g;
	uint8_t b;
} color_t;

/*
typedef struct {
	pixel_t buf[264][264];
	int pos;
} pbuf_t;
*/

// external frame buffer defined in emu.c
extern pbuf_t bg,bbg,fg;
uint32_t fb[SCREEN_H * SCREEN_W];
// color map
uint32_t cmap[64];
static const color_t palette[64] = {
	{ 0x80, 0x80, 0x80 }, 
	{ 0x00, 0x00, 0xBB }, 
	{ 0x37, 0x00, 0xBF }, 
	{ 0x84, 0x00, 0xA6 }, 
	{ 0xBB, 0x00, 0x6A }, 
	{ 0xB7, 0x00, 0x1E }, 
	{ 0xB3, 0x00, 0x00 }, 
	{ 0x91, 0x26, 0x00 }, 
	{ 0x7B, 0x2B, 0x00 }, 
	{ 0x00, 0x3E, 0x00 }, 
	{ 0x00, 0x48, 0x0D }, 
	{ 0x00, 0x3C, 0x22 }, 
	{ 0x00, 0x2F, 0x66 }, 
	{ 0x00, 0x00, 0x00 }, 
	{ 0x05, 0x05, 0x05 }, 
	{ 0x05, 0x05, 0x05 }, 
	{ 0xC8, 0xC8, 0xC8 }, 
	{ 0x00, 0x59, 0xFF }, 
	{ 0x44, 0x3C, 0xFF }, 
	{ 0xB7, 0x33, 0xCC }, 
	{ 0xFF, 0x33, 0xAA }, 
	{ 0xFF, 0x37, 0x5E }, 
	{ 0xFF, 0x37, 0x1A }, 
	{ 0xD5, 0x4B, 0x00 }, 
	{ 0xC4, 0x62, 0x00 }, 
	{ 0x3C, 0x7B, 0x00 }, 
	{ 0x1E, 0x84, 0x15 }, 
	{ 0x00, 0x95, 0x66 }, 
	{ 0x00, 0x84, 0xC4 }, 
	{ 0x11, 0x11, 0x11 }, 
	{ 0x09, 0x09, 0x09 }, 
	{ 0x09, 0x09, 0x09 }, 
	{ 0xFF, 0xFF, 0xFF }, 
	{ 0x00, 0x95, 0xFF }, 
	{ 0x6F, 0x84, 0xFF }, 
	{ 0xD5, 0x6F, 0xFF }, 
	{ 0xFF, 0x77, 0xCC }, 
	{ 0xFF, 0x6F, 0x99 }, 
	{ 0xFF, 0x7B, 0x59 }, 
	{ 0xFF, 0x91, 0x5F }, 
	{ 0xFF, 0xA2, 0x33 }, 
	{ 0xA6, 0xBF, 0x00 }, 
	{ 0x51, 0xD9, 0x6A }, 
	{ 0x4D, 0xD5, 0xAE }, 
	{ 0x00, 0xD9, 0xFF }, 
	{ 0x66, 0x66, 0x66 }, 
	{ 0x0D, 0x0D, 0x0D }, 
	{ 0x0D, 0x0D, 0x0D }, 
	{ 0xFF, 0xFF, 0xFF }, 
	{ 0x84, 0xBF, 0xFF }, 
	{ 0xBB, 0xBB, 0xFF }, 
	{ 0xD0, 0xBB, 0xFF }, 
	{ 0xFF, 0xBF, 0xEA }, 
	{ 0xFF, 0xBF, 0xCC }, 
	{ 0xFF, 0xC4, 0xB7 }, 
	{ 0xFF, 0xCC, 0xAE }, 
	{ 0xFF, 0xD9, 0xA2 }, 
	{ 0xCC, 0xE1, 0x99 }, 
	{ 0xAE, 0xEE, 0xB7 }, 
	{ 0xAA, 0xF7, 0xEE }, 
	{ 0xB3, 0xEE, 0xFF }, 
	{ 0xDD, 0xDD, 0xDD }, 
	{ 0x11, 0x11, 0x11 }, 
	{ 0x11, 0x11, 0x11 }
};
void hal_set_bg_color(int c);
void hal_flush_buf(pbuf_t* buf); // this should take a pixel buffer array..
void hal_flip_display();
void hal_init();
int  hal_key_state(int b);
void hal_free();

#endif
